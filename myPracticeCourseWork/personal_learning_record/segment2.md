[Contents](../personal_learning_record/personal_learning_record.md) | [Segment 2 - Languages and OS](../personal_learning_record/segment2.md) 

# Segment 2 - Languages and Operating Systems

---
**NOTE**

For each of the sessions, bullet point notes on what you have learnt.
Use markdown references and / or links to resources you have used
use  screen shots and / or code samples as appropriate.

---

## session 5

In this session, I learned about the different levels of computer programming languages and how they interact with a computer's hardware. Below is a summary of what I covered in session 5:

1. **Machine code, Assembly code and High-Level Languages**:

**Machine code**: The cpu runs binary instructions which are difficult for humans to understand and design.

**Assembly Code**: An assembler converts a human-readable form of machine-code which is specific to the processor.

**High-Level Languages**: It is easier for programmers to use because it focuses on concepts rather than hardware details. 


I revisited how processors handle instructions using a simulated 4-bit processor.

I examined how binary machine code translates into assembly and how it runs on the processor.

I explored the differences between assembly and compiled programs and how they are prepared for execution.

This session helped me understand the basics of how programs are created and executed at different levels, from machine code to high-level languages.


## session 6

In this session, I learned about the structure of a modern operating system and worked with Assembler and C programming on simulated and real hardware. Here's a summary of what I covered:

1. **Modern Operating Systems**:

Operating systems act as an intermediary between hardware and software, managing resources and providing services for applications.

1. **Programming on the CPUlator**:

I used **Assembler and C code** to control simulated **7-segment displays** on the CPUlator.

This exercise demonstrated how low-level programming interacts directly with hardware components.

1. **Programming on the Raspberry Pi**:

I explored examples of using Assembler and C programming on the Raspberry Pi.

This helped me understand how to transition from simulated environments to real-world hardware.



## session 7

## session 8 (consolidate)

TBD

