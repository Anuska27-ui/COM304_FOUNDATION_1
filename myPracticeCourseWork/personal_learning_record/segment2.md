[Contents](../personal_learning_record/personal_learning_record.md) | [Segment 2 - Languages and OS](../personal_learning_record/segment2.md) 

# Segment 2 - Languages and Operating Systems

---
**NOTE**

For each of the sessions, bullet point notes on what you have learnt.
Use markdown references and / or links to resources you have used
use  screen shots and / or code samples as appropriate.

---

## session 5


In this session, I learned about the different levels of computer programming languages and how they interact with a computer's hardware. Below is a summary of what I covered and some key points from the session:

1. **Machine Code, Assembly Code, and High-Level Languages**:

**Machine Code**: The CPU runs binary instructions which are difficult for humans to write and understand.

**Assembly Code**: An assembler converts human readable versions of machine code which is particular to the processor.

**High-Level Languages**: It's easier to understand for the programmers because it focuses on concepts rather than hardware details. These are converted into machine code by compilers or interpreters.

**Interpreted vs. Compiled Languages**:

**Interpreted Languages** (e.g., Python, JavaScript): Translate code into machine instructions while it is running which speeds up development but slows execution.

**Compiled Languages** (e.g., C, Java): Translate code into machine instructions beforehand time which requires more preparations but results in speedier and more simpler apps.

**How Programs are Prepared to Run**:

Linkers and loaders are components that connect and load programs and libraries into memory which prepares them for execution by the CPU.

**Open Source vs. Closed Source**:

Open-source systems such as linux make their original source code available for others to study, use or modify.

Closed-source systems protect designs by keeping the source code hidden.

**Some online research i did -**

Machine language is the binary code that computers understand and perform directly whereas assembly language is a human readable machine language version. <https://www.spiceworks.com/tech/tech-general/articles/machine-vs-assembly-language/>.

This reference has a lot of good points about assembly and machine language with a clear definition of both of the topics. It helped me learn more about the topics and gain more information.

**Practical Work**:

We looked at how CPUs handle instructions again using a simulated 4-bit processor in the class , it was one of our exercises.

Also we looked at how binary machine code translates into assembly and runs on the processor.

I also had a look at the differences between assembly and compiled programs as well as how they are prepared for operations.

This session helped me understand the basics of how programs are written and performed at various levels from machine code to high-level languages. To expand my knowledge I will find more resources online and look through videos related to the topic covered in this session.



## session 6

In this session I learned about the structure of a modern operating system and worked with Assembler and C programming on simulated and real hardware along with the RaspberryPi. Below is a summary of what I covered in this session:

1. **Modern Operating Systems**:

Operating systems serve as a bridge between hardware and software which manages resources and delivers services to applications.

1. **Programming on the CPUlator**:

I used Assembler and C code to create simulated 7-segment displays on the CPUlator.

This exercise identified how low level-programming works directly with hardware components.

1. **Programming on the Raspberry Pi**:

I looked at examples of using Assembler and C programming on the RaspberryPi.

This helped me understand how to move from simulated to real-world hardware.

This session was more of practical work rather than theory so I only focused on the exercises from the session to get more ideas on how these programming languages work.

### **Key Points from the session:**

- Operating systems are very important for controlling software-hardware interactions.
- Working with Assembler and C on the CPUlator helped me to practice low level programming skills.
- Using the same techniques on the RaspberryPi provided practical understanding with real hardware.

For further learning I will use online resources to deepen my understanding on the topics above. I will also look at advanced operating system topics like file systems, security and so on.


## session 7

We started this session with an overview of the linux operating system. We also did practical exercises for installing and configuring the Apache web server on a RaspberryPi. Below I am going to talk about what I learned in the session with some key points.

Operating system structure -

The kernel contains core functions like scheduling, memory management and device drivers.

User space utilities - Shell commands, file management and visual interfaces.

File system and security -

Hierarchical structure with file permissions ( rwx for owner, group and all users).

Web server deployment -

Installing and configuring Apache2 , managing services and developing basic web pages.

To install Apache we used “sudo apt install apache2”. After installing Apache we tested server functionality by accessing [**http://localhost**](http://localhost).

This session helped me learn more about operating systems which is essential for understanding how computers work. Linux in particular is an essential component of modern computing due to its use in services, cloud platforms and embedded devices. Also the practical work with Linux and Apache server setup helped me learn some valuable skills.

Next step to consolidate knowledge -

I will practice with more HTML pages using advanced tags like forms, tables and multimedia. Also I will look at some books as well.

## session 8 (consolidate)

In this session I looked at past exercises and did some of them again and went through the Cisco Cyber Security System.

TBD

